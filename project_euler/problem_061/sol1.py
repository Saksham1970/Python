"""
Project Euler 61
https://projecteuler.net/problem=61

Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers
are all figurate (polygonal) numbers and are generated by the following formulae:
Triangle 	  	P3,n=n(n+1)/2 	  	1, 3, 6, 10, 15, ...
Square 	  	    P4,n=n2 	  	    1, 4, 9, 16, 25, ...
Pentagonal 	  	P5,n=n(3n-1)/2 	  	1, 5, 12, 22, 35, ...
Hexagonal 	  	P6,n=n(2n-1) 	  	1, 6, 15, 28, 45, ...
Heptagonal 	  	P7,n=n(5n-3)/2 	  	1, 7, 18, 34, 55, ...
Octagonal 	  	P8,n=n(3n-2) 	  	1, 8, 21, 40, 65, ...

The ordered set of three 4-digit numbers: 8128, 2882, 8281,
has three interesting properties.

    The set is cyclic, in that the last two digits of each number is
    the first two digits of the next number (including the last number with the first).
    Each polygonal type: triangle (P3,127=8128), square (P4,91=8281),
    and pentagonal (P5,44=2882), is represented by a different number in the set.
    This is the only set of 4-digit numbers with this property.

Find the sum of the only ordered set of six cyclic 4-digit numbers for which
each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal,
is represented by a different number in the set.

"""


# Defining the figurative numbers
def triangle(num: int) -> int:
    """
    Figurative number defined in the question.
    >>> triangle(1)
    1
    >>> triangle(2)
    3
    """
    return num * (num + 1) // 2


def square(num: int) -> int:
    """
    Figurative number defined in the question.
    >>> square(1)
    1
    >>> square(2)
    4
    """
    return num**2


def pentagonal(num: int) -> int:
    """
    Figurative number defined in the question.
    >>> pentagonal(1)
    1
    >>> pentagonal(2)
    5
    """
    return num * (3 * num - 1) // 2


def hexagonal(num: int) -> int:
    """
    Figurative number defined in the question.
    >>> hexagonal(1)
    1
    >>> hexagonal(2)
    6
    """
    return num * (2 * num - 1)


def heptagonal(num: int) -> int:
    """
    Figurative number defined in the question.
    >>> heptagonal(1)
    1
    >>> heptagonal(2)
    7
    """
    return num * (5 * num - 3) // 2


def octagonal(num: int) -> int:
    """
    Figurative number defined in the question.
    >>> octagonal(1)
    1
    >>> octagonal(2)
    8
    """
    return num * (3 * num - 2)


def solution() -> int:
    """
    Finds every 4 digit figurative numbers and groups them into
    pairs, triplets, and at last a full circle to find the solution.

    >>> solution()
    28684

    """

    functions = [triangle, square, pentagonal, hexagonal, heptagonal, octagonal]

    # Ranges for which the values are 4 digit, ie between 1000 and 9999
    ranges = [(45, 141), (32, 100), (26, 82), (23, 71), (21, 64), (19, 59)]

    # Storing the first 2 and last 2 digits of each number separately
    # starts[0] means list of all first 2 digits of triangle numbers
    # starts[1] means list of all first 2 digits of square numbers
    # ends[0] means list of all last 2 digits of triangle numbers
    # ends[1] means list of all last 2 digits of square numbers
    starts: list[list[int]] = []
    ends: list[list[int]] = []

    # Filling starts and ends
    for function_index in range(6):
        ends.append([])
        starts.append([])
        for num in range(ranges[function_index][0], ranges[function_index][1]):
            figurate_num = functions[function_index](num)
            ends[function_index].append(figurate_num % 100)
            starts[function_index].append(figurate_num // 100)

    # Pairs list stores the pair of numbers whose ones end == others start
    # It stores in format:
    # (head_function_index, tail_function_index, head_number_index, tail_number_index )
    pairs = []
    for head_function_index in range(6):
        for head_number_index in range(len(ends[head_function_index])):
            for tail_function_index in range(6):
                if tail_function_index != head_function_index:
                    for tail_number_index in range(len(starts[tail_function_index])):
                        if (
                            ends[head_function_index][head_number_index]
                            == starts[tail_function_index][tail_number_index]
                        ):
                            pairs.append(
                                (
                                    head_function_index,
                                    tail_function_index,
                                    head_number_index,
                                    tail_number_index,
                                )
                            )
    HEAD_FUNCTION = 0
    TAIL_FUNCTION = 1
    HEAD_NUMBER = 2
    TAIL_NUMBER = 3

    # Triples list stores the triples of numbers made
    # from pairs list where ones end == others start
    # It stores in format:
    # (head_function_index, middle_function_index, tail_function_index,
    # head_number_index, tail_number_index )
    triples = []
    for pair1 in pairs:
        for pair2 in pairs:
            if (
                (pair1[TAIL_FUNCTION] == pair2[HEAD_FUNCTION])
                and (pair1[TAIL_NUMBER] == pair2[HEAD_NUMBER])
                and (pair1[HEAD_FUNCTION] != pair2[TAIL_FUNCTION])
            ):
                triple = (
                    pair1[HEAD_FUNCTION],
                    pair1[TAIL_FUNCTION],
                    pair2[TAIL_FUNCTION],
                    pair1[HEAD_NUMBER],
                    pair2[TAIL_NUMBER],
                )
                if triple not in triples:
                    triples.append(triple)

    HEAD_FUNCTION = 0
    MIDDLE_FUNCTION = 1
    TAIL_FUNCTION = 2
    HEAD_NUMBER = 3
    TAIL_NUMBER = 4

    # six_circles list stores the full circle of 6 numbers made
    # from triples list where ones end == others start
    # It stores in format (function1_index, function2_index, ... , function6_index,
    # function1_number_index)
    # 6 circles will be formed from 6 numbers each number as function 1 and repeating
    six_circles = []
    for triple1 in triples:
        for triple2 in triples:
            if (
                len(set(triple1[:3] + triple2[:3])) == 6
                and ends[triple1[TAIL_FUNCTION]][triple1[TAIL_NUMBER]]
                == starts[triple2[HEAD_FUNCTION]][triple2[HEAD_NUMBER]]
                and starts[triple1[HEAD_FUNCTION]][triple1[HEAD_NUMBER]]
                == ends[triple2[TAIL_FUNCTION]][triple2[TAIL_NUMBER]]
            ):
                six_circle = (
                    triple1[HEAD_FUNCTION],
                    triple1[MIDDLE_FUNCTION],
                    triple1[TAIL_FUNCTION],
                    triple2[HEAD_FUNCTION],
                    triple2[MIDDLE_FUNCTION],
                    triple2[TAIL_FUNCTION],
                    triple1[HEAD_NUMBER],
                )
                if six_circle not in six_circles:
                    six_circles.append(six_circle)

    sum = 0
    for six_circle in six_circles:
        sum += starts[six_circle[0]][six_circle[-1]] * 100
        sum += ends[six_circle[0]][six_circle[-1]]
    return sum


if __name__ == "__main__":
    print(f"{solution() = }")
